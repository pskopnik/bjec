from enum import Enum
from types import TracebackType
from typing import Any, Dict, Iterator, List, Mapping, Optional, Type, Union

from classad import ClassAd, ExprTree


class TransactionFlags(Enum):
    NonDurable = ...
    SetDirty = ...
    ShouldLog = ...


class QueryOpts(Enum):
    Default = ...
    AutoCluster = ...
    GroupBy = ...
    DefaultMyJobsOnly = ...
    SummaryOnly = ...
    IncludeClusterAd = ...


class JobAction(Enum):
    Hold = ...
    Release = ...
    Suspend = ...
    Continue = ...
    Remove = ...
    RemoveX = ...
    Vacate = ...
    VacateFast = ...


class Transaction:
    def __enter__(self) -> 'Transaction': ...
    def __exit__(
        self,
        exc_type: Optional[Type[BaseException]] = None,
        exc_val: Optional[BaseException] = None,
        exc_tb: Optional[TracebackType] = None,
    ) -> Optional[bool]: ...


class SubmitResult:
    def cluster(self) -> int: ...
    def clusterad(self) -> ClassAd: ...
    def first_proc(self) -> int: ...
    def num_procs(self) -> int: ...


class Submit(Mapping[str, str]):
    def __init__(self, **kwargs: Any) -> None: ...

    def __iter__(self) -> Iterator[str]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, k: str) -> str: ...

    # ad_results might be Optional[...]?
    def queue(self, txn: Transaction, count: int = ..., ad_results: List[ClassAd] = ...) -> int: ...
    # itemdata might be Optional[...]?
    def queue_with_itemdata(self, txn: Transaction, count: int = ..., itemdata: Iterator[Union[str, Dict[str, str]]] = ...) -> SubmitResult: ...


class QueryIterator(Iterator[ClassAd]):
    def __iter__(self) -> 'QueryIterator': ...
    def __next__(self) -> ClassAd: ...
    def nextAdsNonBlocking(self) -> List[ClassAd]: ...
    def tag(self) -> str: ...
    def done(self) -> bool: ...
    def watch(self) -> int: ...


class Schedd:
    def __init__(self) -> None: ...
    def transaction(self, flags: TransactionFlags = ..., continue_txn: bool = ...) -> Transaction: ...
    # name might be Optional[...]?
    def xquery(self, requirements: Union[str, ExprTree] = ..., projection: List[str] = ..., limit: int = ..., opts: QueryOpts = ..., name: str = ...) -> QueryIterator: ...
    def act(self, action: JobAction, job_spec: Union[List[str], str], reason: Optional[str] = ...) -> ClassAd: ...
